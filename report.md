# University medical school software development project
## Team Members:
|Teams name| Git Hub credentials |
|----------|---------------------|
|Emily SJ|EthSpJo |
|Jacob S1| facade93coat|
|Anna D|AnnaD2022 |
|Anon Thomas|TorinM321 |

## Team Management
#### Team Leadership
<p>Rather than choosing one person to lead the entire team, we adopted a democratised system, in which all major project decisions were made as a group.  If there were any disagreements, each programmer was allowed to explain their reasoning, and a compromise was found that suited all parties.  We found that this approach led to an open and understanding work environment, in which any member could ask for help or give suggestions, and nobody was forced to work on something they didn't enjoy or didn't have the time to do.  Overall, we believe that this approach certainly resulted in a higher quality product than would have otherwise been produced and a greater increase in programmer skill then would otherwise have been achieved as it facilitated an greater number of learning and development oppertunities .</p>
<br>

#### Work division
<p>Work was divided evenly between all members of the team based on strengths and prior experience. The fact that some team members were together in person at the time of project commencement and some were not also impacted work division. In person team members worked together to produce the main code components, and those who were virtual adopted the equivalant of a Quality Assurance role, carrying out tests on the code and suggesting improvements with an objective eye as they had not been involved in its production.</p> <p> Documentation such as this report and any linked documents was a team effort, completed by the team members most familiar with a certain section and peer assessed by other team members to ensure quality, clarity and detail were maintained.</p>

|Teams name| Contributions |
|----------|---------------|
|Emily SJ|[Tests plan](https://github.com/AnnaD2022/QA-FTP-Project/blob/main/test_plans.md) <br> [class_function_descriptors](https://github.com/AnnaD2022/QA-FTP-Project/blob/main/class_function_descriptors.md) <br> [test_check_header (validate_file function)](https://github.com/AnnaD2022/QA-FTP-Project/blob/main/test_check_header.py) <br> [test_check_ids (validate_file function)](https://github.com/AnnaD2022/QA-FTP-Project/blob/main/test_check_ids.py) <br> [test_check_readings (validate_file function)](https://github.com/AnnaD2022/QA-FTP-Project/blob/main/test_check_readings.py)] <br> [test_main_checkDate (main function)](https://github.com/AnnaD2022/QA-FTP-Project/blob/main/test_main_checkDate.py) <br> [test_num_columns (validate_files function)](https://github.com/AnnaD2022/QA-FTP-Project/blob/main/test_num_columns.py) <br> [test_remove_empty (validate_file function)](https://github.com/AnnaD2022/QA-FTP-Project/blob/main/test_remove_empty.py) <br> [test_row_num (validate_files function)](https://github.com/AnnaD2022/QA-FTP-Project/blob/main/test_row_num.py) <br> [test_timestamp (validate_file function)](https://github.com/AnnaD2022/QA-FTP-Project/blob/main/test_timestamp.py) <br> All files in the 'tests' folder <br> Documentation|
|Jacob S1| [server.py](https://github.com/AnnaD2022/QA-FTP-Project/blob/main/server.py) <br> [client.py](https://github.com/AnnaD2022/QA-FTP-Project/blob/main/client.py) <br> [README.md](https://github.com/AnnaD2022/QA-FTP-Project/blob/main/README.md) <br> Documentation|
|Anna D|[validate_file](https://github.com/AnnaD2022/QA-FTP-Project/blob/main/validate_file.py)<br> [README.md](https://github.com/AnnaD2022/QA-FTP-Project/blob/main/README.md) <br> [class_function_descriptors](https://github.com/AnnaD2022/QA-FTP-Project/blob/main/class_function_descriptors.md) <br> File archive <br> Documentation|
|Anon Thomas|[main.py](https://github.com/AnnaD2022/QA-FTP-Project/blob/main/main.py) |
<br>

#### Meeting organisation
<p>Team meetings were arranged using our group teams chat. These meetings either took the form of all team members being present in the team chat at a dedicated time discussing, in text form, varying aspects of the project; teams calls or, as seen in weeks 1 and 2 of the project, team members getting together in person to examine the current state of the repository and discuss next steps.  Meetings were called on an ad-hoc basis, occuring when a significant decision needed to be made, a large section of the code had been completed, or a member had a query.  We found that this approach was more efficient than having meetings occur on a scheduled basis, as it meant that there was always a specific purpose and goal for each conversation.</p>
<br>

#### Time Management
<p>On the whole, our group's time management was very good, working in short sprints to develop features and sticking to our agreed deadlines despite the short timeframe we were working under and the additional pressure of the upcoming deadline for personal projects.</p>

<p>Despite this initial success, the unforseen challenge of a team member failing to complete their assigned feature meant that we had to adapt quickly to maximise productivity in the limited time we had remaining before the project deadline.
The remaining team members called a meeting to tackle the issue, efficiently reassigning the remaining tasks and agreeing on a meeting the next day to make sure that everything was fully completed in time.  As a result, we were able to use the time we has as efficiently as possible given the circumstances, and produced a final and fully completed version of the project with time to spare for quality assurance.</p>

<br>

#### Cooperation
- TODO all <br>
<p>In regards to cooperation between team members, everything generally went smoothly, with most team members completing their assigned tasks in a timely manner and checking teams on a regular basis.</p>
  <p>As mentioned previously, a teams chat was established for developers to update eachother on their progress; this soon became a way for team members to ask for and provide help with certain sections of code, as well as to suggest improvements to other people's code.</p>
  <p>All team members also attempted to adhere to best practices when writting commit messages and descriptions as well as when generating comments in their code to ensure they remained clear and conscise and thus enable other team members to understand exactly what changes were being made where and when and consequently how this could impact their deliverables. </p>
    <p>Due to personal commitments and time constraints, we were unable to meet as a full team frequently. As such, miscommunication and misunderstandings occurred and so, in order to satisfy requirements in time for the deadline, some responsibilities were moved around towards the end. In doing this we maintained good communication practices, keeping the line of communication open with summaries of any meetings; documenting how responsibilities had been redistributed in our MS teams chat and continuing to notify one another when a change was made to deliverables </p>

<br>

## Approach to deliverables
#### Choice of programming language
<p>As a team we decided to complete the entire project in python, as all team members have previous experience with the language, and thus felt more confident using it than C or PowerShell.  Additionally, file handling, data processing and data manipulation, which are all integral parts of the task are, in our opinion, much simpler in python than the other languages permitted.</p>

<br>

#### Use of version control
<p>As a team we decided to use GitHub to facilitate version control throughout the completion of the project. This was in part due to the fact all members of the team had prior experience using GitHub or GitLab and thus were familiar with the processes involved in interacting with a repository as well as GitHubs ability to act as a secure, private host for our code; but mostly as a result the many features GitHub offers. </p> 
<p>Auto-resolution of conflicts when multiple members of the team had collaborated on the same area of code helped us to increase the efficiency with which we produced working features. The ability to quickly and easily share what we were working on with one another using the simple commit, push and pull commands aided in our collaborative process as we could keep up to date with what others were doing and shape our code to best suit these deliverables thus also ensuring our code remained cohesive and clear. </p>
<p>The chronological order with which commits are registered and stored in the GitHub repository as well as team members descriptive commit messages, also enabled us to refer or return to prior versions as needed and understand exactly what changes had been made when updated versions of the code no longer functioned as expected to facilitate a faster issue resolution process.</p><br> Overal, adoption of a GitHub repository has facilitated our efficient production of a quality product that meets outlined project requirements.

<br>

#### Software development approaches
<p>We decided to use the "Comment Driven Development" approach, in which the entire project is pseudocoded using comments before being written in full python code.  This allowed us to plan the code thoroughly before beginning, reducing the amount of times sections needed to be rewritten due to unforseen requirements, and refining the implementation to be as efficient as possible before development began.  A further benefit was that the implementation of different sections could be properly discussed with the entire team before they were implemented, preventing miscommunication and better facilitating the integration of code sections written independently by different team members.</p>
<p>We also implemented our own take on 'feature driven development'. Each team member was given an overarching feature of the project, for example Jacob was assigned the client-server connectivity feature of the product. Each team member then identified the smaller features (for example, individual functions) within that overarching feature and implemented them one at a time, within an agreed time frame. </p>

<p>Linking to this, we adopted informal sprints. Due to the time restrictions on the project, industry standard two week long sprints were not feasible, however short sprints lasting between two and three days in which each team member aimed to produce a set section of the their portion of the code did occur throughout the project.  Such sprints usually took place after meetings regarding progress, following identification from one team member that a currently incomplete section of another person's code would be needed for them to complete their work. </p>
<p>Pair programming was not used significantly during initial development as a result of our feature driven approach. However, this approach was utilised during the testing and review stage of the project, in which either in pairs or as an entire team we worked together to resolve identified bugs and change working implementations of sections of the code to improve efficiency, amongst other issues, with an objective eye.</p>

<br>

## Problem solving
<p>Throught the duration of this project, the teams primary approach to solving any issues that arose was a collaborative discussion either in our MS teams chat or a 'face to face' meeting in which encountered problems were broken down into sections and distributed to the team members with the most experience in that area. This problem solving metholodgy can be seen in our approach to the project as a whole; the overal system was split into 4 notable 'chunks': verification of input data, the client/server, the user interface and quality control following an intial meeting and establishment of each others strengths and weaknesses.</p>
<p>Maintaining this collborative approach has allowed our solution to be produced to a high standard as team member experience and research ability was combined in the face of errors to identify the best solution that not only illiminated the issue but also best suited our code and stylistic approach. Practically, following discussions and agreement of a course of action to resolve an issue discovered in testing for example, changes to code were either implemented by Emily SJ with the oversight from the relevant code owner or, if it was a larger, more involved fix, the code owner themselves. The benefit of this was that the underlying logic of functions was not compromised with changes made but also that different members of the team got the oppertunity to interact with all areas of the code furthering our understanding of the solution.</p>
<br>

#### Bug fixing
<p>In regards to bugs, obscure errors such as value errors were predominantly discovered during the testing portion of development. When a bug was discovered, a note was made in the code and the test plan for any corresponding test that consequently failed, detailing why the failure occured. We then used our group teams chat to collaboratively discuss possible solutions as well as how any subsequent changes would impact other aspects of the code and how changes could be implemented whilst maintaining the integrity of other developers work.</p>
<p>Code that needed to be changed was then commented out in the relevant function with a note indicating why and the new code implemented around it.</p>
<p>We chose to leave prior code in, albeit commented out, as we felt it demonstrated our refinement processes and would help newcomers to the code to understand any deviations from the initial plans for the function logic and other altered plans.</p>

<br>

## Code
### Classes
[client.py](https://github.com/AnnaD2022/QA-FTP-Project/blob/main/client.py) <br>
[server.py](https://github.com/AnnaD2022/QA-FTP-Project/blob/main/server.py) <br>
[main.py](https://github.com/AnnaD2022/QA-FTP-Project/blob/main/main.py) <br>
[validate_file.py](https://github.com/AnnaD2022/QA-FTP-Project/blob/main/validate_file.py) <br>


### Class Function Descriptors
Detailed descriptions of the purpose of each section of the code can be found at the link below: <br>
[Class function descriptors document](https://github.com/AnnaD2022/QA-FTP-Project/blob/main/class_function_descriptors.md) 
- TODO - fill these out when all code finalised (jacob)

TODO - why chose GUI not CLI (jacob?)

### Assumptions
<p>When interpreting the brief provided, Anna D, who was working on the file validation and archiving portion of the project, found that she needed to make some assumptions about what a "valid" file consisted of, based on the test data provided.  They are included below for clarity, and the code has been designed to be easily adaptable to any changes in requirements.</p>
<ol>
<li> Assume all files must have 10 rows (not including  the header)</li>

<li> Assume readings do not need ending 0s (e.g. 6 does not need to be stored as 6.000) - readings under 3dp are valid but above 3dp are not and should be rounded </li>

<li> Assume 0 and 10 are not valid readings (range is 0 < reading < 10, rather than 0<= reading <= 10) </li>

<li> Assume bad filenames handled by server</li>

<li> Assume batch_id can be 0</li>
</ol>

### Error Code System
<p>In order to better inform a user on why a file was rejected or modified by the validation program, as well as to allow any issues to be reported by the GUI, a system of "error codes" was devised, as included below.  These codes are displayed to the user by the GUI, as well as included in an "info.txt" file stored in the archive alongside the files.</p>

- 000 - Valid File (Logged without preceding "Error")
- 100 - Empty File
- 101 - Header Only
- 200 - Incorrect Header
- 201 - Fatal Incorrect Header
- 300 - Missing Values
- 400 - Incorrect Number of Rows
- 500 - Invalid Batch ID
- 600 - Too Many Values (deprecated)
- 700 - Incorrect Timestamp
- 800 - Int, Not Float
- 801 - Incorrect Data Type
- 802 - Incorrect Rounding
- 803 - Value Out of Range

### File Archive Structure
<p>Once each file in the to_check folder has been checked against the requirements, it is moved into the file archive.  Depending on a flag set by the validation program, the csv file and its respective info file are moved into either the "rejected" or "successful" directory.  Each directory is subdivided into several further directories in a tree-like structure based around the date in the name of the file, with the year at the root, branching out further by month and then finally by day. </p>
<p>The encapsulating "files" directory also contains a text file logging all of the files that have already been downloaded to the file system, in order to avoid duplicates.</p>

### README
[README document](https://github.com/AnnaD2022/QA-FTP-Project/blob/main/README.md)
## Test Plans
[Test plan document](https://github.com/AnnaD2022/QA-FTP-Project/blob/main/test_plans.md)
<br>

#### Key notes:
- The unit test scripts are linked within the test plan document, they can also be found in the [main project repo](https://github.com/AnnaD2022/QA-FTP-Project)
- The csv files used within the tests can be found in the [tests folder](https://github.com/AnnaD2022/QA-FTP-Project/tree/main/tests)
- As a team we decided not to develop tests for 'server.py'. This is beacuse this code was heavily influenced by existing, available server code and thus known to work as required.
<br>

#### Overall testing approach
##### validate_files:
The predominant approach when testing the functions in the validate_files script was to pass in one of the testing csv files found within the tests folder of the repository and then use 'assertTrue/ assertFalse' to verify the correct value had been returned by the function and also 'assertTrue' alongside a test to ensure, when relevant, a log file had been created. This method enabled us to ensure that the functions were not only behaving logically as intended but also were generating files in the correct location and under the correct name format.

##### main
The main.py script generates the GUI and based on user interaction with that GUI calls relevant functions. The nature of the logic involved would have made it ineffective to call included functions in an isolated manner. Instead, the entire script is called and specific inputs and expected outputs defined to facilitate a 'check by inspection' approach.

##### client
**Note: for the client tests to work the server.py script needs to be executing in the background** <br>
The client tests predominently function by validating the expected return value is generated given a valid or invalid date plus manipulation of the clients server credentials.

